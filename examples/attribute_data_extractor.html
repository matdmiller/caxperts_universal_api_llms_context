<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="transparent" content="true">
    <title>Attribute Data Extractor</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            padding: 20px;
            background-color: rgba(33, 37, 41, 0.8);
            color: white;
        }
        .card {
            background-color: rgba(50, 55, 60, 0.8);
        }
        #outputArea {
            background-color: rgba(0, 0, 0, 0.2);
            color: white;
            font-family: monospace;
            height: 300px;
            resize: vertical;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .attribute-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            padding: 15px;
            background-color: rgba(0, 0, 0, 0.1);
        }
        .form-check {
            margin-bottom: 8px;
        }
        .form-check-input:checked {
            background-color: #0d6efd;
            border-color: #0d6efd;
        }
        .attribute-count {
            font-size: 0.9em;
            color: #adb5bd;
        }
        .settings-header {
            cursor: pointer;
            user-select: none;
        }
        .settings-header:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card mb-4">
            <div class="card-header">
                <h2>Attribute Data Extractor</h2>
            </div>
            <div class="card-body">
                <p>Export attribute data for all selected items in UPV in TSV format.</p>
                
                <!-- Attribute Settings Section -->
                <div class="mb-4">
                    <div class="settings-header p-2 rounded" data-bs-toggle="collapse" data-bs-target="#attributeSettings">
                        <h5 class="mb-0">
                            <i class="bi bi-chevron-down me-2" id="settingsChevron">â–¼</i>
                            Attribute Selection Settings
                            <span class="attribute-count ms-2" id="selectedCount">(0 selected)</span>
                        </h5>
                    </div>
                    <div class="collapse show" id="attributeSettings">
                        <div class="mt-3">
                            <div class="d-flex gap-2 mb-3">
                                <button id="selectAllBtn" class="btn btn-outline-primary btn-sm">Select All</button>
                                <button id="selectNoneBtn" class="btn btn-outline-secondary btn-sm">Select None</button>
                            </div>
                            <div class="attribute-list" id="attributeList">
                                <div class="text-muted">Select objects in UPV to see available attributes</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="mb-3">
                    <button id="extractButton" class="btn btn-primary">Extract Attribute Data</button>
                </div>
                <div class="mb-3">
                    <div class="d-flex justify-content-between mb-2">
                        <label for="outputArea" class="form-label">Output (TSV format)</label>
                        <button id="copyButton" class="btn btn-secondary btn-sm">Copy to Clipboard</button>
                    </div>
                    <textarea id="outputArea" class="form-control" readonly></textarea>
                </div>
                <div id="status" class="alert alert-info">Ready - select objects in UPV and click Extract</div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay d-none">
        <div class="spinner-border text-light" role="status" style="width: 3rem; height: 3rem;">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>

    <!-- Bootstrap JS Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Universal API -->
    <script src="https://matdmiller.github.io/caxperts_universal_api_llms_context/universal-api.umd.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const extractButton = document.getElementById('extractButton');
            const copyButton = document.getElementById('copyButton');
            const outputArea = document.getElementById('outputArea');
            const statusEl = document.getElementById('status');
            const loadingOverlay = document.getElementById('loadingOverlay');
            const attributeList = document.getElementById('attributeList');
            const selectAllBtn = document.getElementById('selectAllBtn');
            const selectNoneBtn = document.getElementById('selectNoneBtn');
            const selectedCount = document.getElementById('selectedCount');
            const settingsChevron = document.getElementById('settingsChevron');
            
            // Storage key for selected attributes
            const STORAGE_KEY = 'attributeExportSettings';
            const MAX_OBJECTS = 1000;
            
            // Track available attributes and their selection state
            let availableAttributes = new Set();
            let selectedAttributes = new Set();
            let currentObjects = [];
            
            // Initialize Universal API
            const app = UniversalApi.universal_api.Application.getInstance();

            // Load saved selections from localStorage
            function loadSavedSelections() {
                try {
                    const saved = localStorage.getItem(STORAGE_KEY);
                    if (saved) {
                        selectedAttributes = new Set(JSON.parse(saved));
                    }
                } catch (error) {
                    console.warn('Failed to load saved selections:', error);
                    selectedAttributes = new Set();
                }
            }

            // Save selections to localStorage
            function saveSelections() {
                try {
                    localStorage.setItem(STORAGE_KEY, JSON.stringify([...selectedAttributes]));
                } catch (error) {
                    console.warn('Failed to save selections:', error);
                }
            }

            // Update the selected count display
            function updateSelectedCount() {
                const visibleSelected = [...selectedAttributes].filter(attr => availableAttributes.has(attr)).length;
                const total = availableAttributes.size;
                selectedCount.textContent = `(${visibleSelected} of ${total} selected)`;
            }

            // Show loading overlay
            function showLoading() {
                loadingOverlay.classList.remove('d-none');
            }

            // Hide loading overlay
            function hideLoading() {
                loadingOverlay.classList.add('d-none');
            }

            // Update attribute list UI
            function updateAttributeList() {
                if (availableAttributes.size === 0) {
                    attributeList.innerHTML = '<div class="text-muted">Select objects in UPV to see available attributes</div>';
                    updateSelectedCount();
                    return;
                }

                // Sort attributes alphabetically
                const sortedAttributes = [...availableAttributes].sort();
                
                let html = '';
                sortedAttributes.forEach(attr => {
                    const isChecked = selectedAttributes.has(attr);
                    const checkboxId = `attr_${attr.replace(/[^a-zA-Z0-9]/g, '_')}`;
                    html += `
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="${attr}" id="${checkboxId}" ${isChecked ? 'checked' : ''}>
                            <label class="form-check-label" for="${checkboxId}">
                                ${attr}
                            </label>
                        </div>
                    `;
                });
                
                attributeList.innerHTML = html;
                
                // Add event listeners to checkboxes
                attributeList.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            selectedAttributes.add(this.value);
                        } else {
                            selectedAttributes.delete(this.value);
                        }
                        saveSelections();
                        updateSelectedCount();
                    });
                });
                
                updateSelectedCount();
            }

            // Get unique attributes from selected objects
            async function updateAvailableAttributes() {
                try {
                    showLoading();
                    statusEl.textContent = "Analyzing selected objects...";
                    
                    // Get the 3D scene
                    const scene = (await app.Scenes3d.get())[0];
                    
                    // Get the selected objects with attributes
                    const filter = scene.getNewFilter();
                    filter.IncludeAttributes = true;
                    currentObjects = await filter.getSelectedObjects();
                    
                    if (currentObjects.length === 0) {
                        availableAttributes = new Set();
                        updateAttributeList();
                        statusEl.textContent = "No objects selected. Please select objects in UPV.";
                        hideLoading();
                        return;
                    }
                    
                    // Extract all unique attribute names
                    const attributeSet = new Set();
                    for (const obj of currentObjects) {
                        if (obj.Attributes) {
                            Object.keys(obj.Attributes).forEach(attr => attributeSet.add(attr));
                        }
                    }
                    
                    availableAttributes = attributeSet;
                    updateAttributeList();
                    statusEl.textContent = `Found ${currentObjects.length} selected objects with ${availableAttributes.size} unique attributes`;
                    
                } catch (error) {
                    statusEl.textContent = `Error: ${error.message}`;
                    console.error("Analysis error:", error);
                } finally {
                    hideLoading();
                }
            }

            // Extract attribute data for selected objects
            async function extractAttributeData() {
                try {
                    showLoading();
                    statusEl.textContent = "Processing...";
                    outputArea.value = "";
                    
                    // Get the 3D scene
                    const scene = (await app.Scenes3d.get())[0];
                    
                    // Get the selected objects with attributes
                    const filter = scene.getNewFilter();
                    filter.IncludeAttributes = true;
                    const selectedObjects = await filter.getSelectedObjects();
                    
                    if (selectedObjects.length === 0) {
                        statusEl.textContent = "No objects selected. Please select objects in UPV.";
                        hideLoading();
                        return;
                    }
                    
                    // Check object count limit
                    if (selectedObjects.length > MAX_OBJECTS) {
                        statusEl.className = "alert alert-warning";
                        statusEl.textContent = `Error: Too many objects selected (${selectedObjects.length}). Please select less than ${MAX_OBJECTS} objects or use the UPV report functionality instead.`;
                        hideLoading();
                        return;
                    }
                    
                    // Get selected attributes for export
                    const attributesToExport = [...selectedAttributes].filter(attr => availableAttributes.has(attr)).sort();
                    
                    if (attributesToExport.length === 0) {
                        statusEl.className = "alert alert-warning";
                        statusEl.textContent = "No attributes selected for export. Please select attributes in the settings section.";
                        hideLoading();
                        return;
                    }
                    
                    // Create header for TSV (Uid + selected attributes)
                    let tsvData = "Uid\t" + attributesToExport.join("\t") + "\n";
                    
                    // Process each selected object
                    for (const obj of selectedObjects) {
                        let row = obj.Uid;
                        
                        // Add each selected attribute value
                        for (const attr of attributesToExport) {
                            const value = obj.Attributes && obj.Attributes[attr] ? obj.Attributes[attr] : "";
                            // Escape tabs and newlines in values
                            const escapedValue = String(value).replace(/\t/g, " ").replace(/\n/g, " ").replace(/\r/g, "");
                            row += "\t" + escapedValue;
                        }
                        
                        tsvData += row + "\n";
                    }
                    
                    // Set output
                    outputArea.value = tsvData;
                    statusEl.className = "alert alert-success";
                    statusEl.textContent = `Data extracted for ${selectedObjects.length} objects with ${attributesToExport.length} attributes`;
                } catch (error) {
                    statusEl.className = "alert alert-danger";
                    statusEl.textContent = `Error: ${error.message}`;
                    console.error("Extraction error:", error);
                } finally {
                    hideLoading();
                }
            }

            // Copy output to clipboard
            function copyToClipboard() {
                try {
                    // Select the text
                    outputArea.select();
                    outputArea.setSelectionRange(0, 99999); // For mobile devices
                    
                    // Try the modern clipboard API first
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(outputArea.value)
                            .then(() => {
                                statusEl.className = "alert alert-info";
                                statusEl.textContent = "Copied to clipboard!";
                                setTimeout(() => {
                                    statusEl.className = "alert alert-info";
                                    statusEl.textContent = "Ready - select objects in UPV and click Extract";
                                }, 2000);
                            })
                            .catch(err => {
                                fallbackCopy();
                            });
                    } else {
                        fallbackCopy();
                    }
                } catch (error) {
                    statusEl.className = "alert alert-danger";
                    statusEl.textContent = `Copy failed: ${error.message}`;
                    console.error("Copy error:", error);
                }
            }
            
            // Fallback copy method using execCommand
            function fallbackCopy() {
                try {
                    const successful = document.execCommand('copy');
                    
                    if (successful) {
                        statusEl.className = "alert alert-info";
                        statusEl.textContent = "Copied to clipboard!";
                    } else {
                        statusEl.className = "alert alert-warning";
                        statusEl.textContent = "Copy failed, please select and copy manually";
                    }
                    
                    setTimeout(() => {
                        statusEl.className = "alert alert-info";
                        statusEl.textContent = "Ready - select objects in UPV and click Extract";
                    }, 2000);
                } catch (err) {
                    statusEl.className = "alert alert-warning";
                    statusEl.textContent = "Copy failed, please select and copy manually";
                    console.error("Fallback copy error:", err);
                }
            }

            // Select all attributes
            function selectAllAttributes() {
                availableAttributes.forEach(attr => selectedAttributes.add(attr));
                saveSelections();
                updateAttributeList();
            }

            // Select no attributes
            function selectNoAttributes() {
                // Only remove currently available attributes, preserve others
                availableAttributes.forEach(attr => selectedAttributes.delete(attr));
                saveSelections();
                updateAttributeList();
            }

            // Handle collapse chevron rotation
            document.getElementById('attributeSettings').addEventListener('shown.bs.collapse', function () {
                settingsChevron.textContent = 'â–¼';
            });
            
            document.getElementById('attributeSettings').addEventListener('hidden.bs.collapse', function () {
                settingsChevron.textContent = 'â–¶';
            });

            // Set up event listeners
            extractButton.addEventListener('click', extractAttributeData);
            copyButton.addEventListener('click', copyToClipboard);
            selectAllBtn.addEventListener('click', selectAllAttributes);
            selectNoneBtn.addEventListener('click', selectNoAttributes);
            
            // Update attributes when selection changes (debounced)
            let selectionTimeout;
            function debouncedUpdateAttributes() {
                clearTimeout(selectionTimeout);
                selectionTimeout = setTimeout(updateAvailableAttributes, 500);
            }
            
            // Listen for selection changes if available
            if (app.available()) {
                // Try to set up selection change listener
                try {
                    app.Events.onSelectionChange.add(debouncedUpdateAttributes);
                } catch (error) {
                    console.log("Selection change events not available, manual refresh required");
                }
                
                // Initial load
                loadSavedSelections();
                updateAvailableAttributes();
            } else {
                statusEl.className = "alert alert-danger";
                statusEl.textContent = "Universal API is not available. This app must be run as an AppControl inside UPV.";
                extractButton.disabled = true;
                copyButton.disabled = true;
                selectAllBtn.disabled = true;
                selectNoneBtn.disabled = true;
            }
        });
    </script>
</body>
</html>